Модуль для работы с гибридной IP-ATC MyPBX U100 и биллинговой системой с базой данных MySQL.
Ссылка на документацию http://telefonizator.ru/yeastar-mypbx-u100/documentation.

ОПИСАНИЕ

Модуль представляет собой оконное приложение, которое предоставляет возможность при приеме
звонка считывать входящий номер телефона и производить поиск в базе абонентов биллинга.
Если абонент с таким номером телефона найден, то открывать карточку данного абонента,
для этого в биллинге должен быть реализован API поиск по номеру телефона.
Модуль позволяет ускорить работу технической поддержки с абонентом.

ПРЕДНАСТРОЙКА

Для начала нужно настроить IP-ATC MyPBX.
Как настроить, показано в документации (http://telefonizator.ru/yeastar-mypbx-u100/documentation).

Если в биллинге не реализован поиск абонента, то нужно написать API.

Создать и активировать виртуальное окружение, установить нужные пакеты. (pip install -r requirements.txt)

Далее внести Ваши данные в:
 - комманде подключения к базе данных:
        mysql.connector.connect(
            host="127.0.0.1",
            user="username",
            passwd="password",
            database="database"
        )
 - данные в подключении к серверу IP-ATC:
    telnetlib.Telnet(host='127.0.0.1', port=8000)
 - кортеже auth_commands заполнить username-пользователь и secret-пароль
 - прописать ссылку Вашего биллинга
    webbrowser.open('ссылка')

АЛГОРИТМ РАБОТЫ

Запускается оконное приложение написанное с помощью библиотеки PyQt5.
Для удобства был использованн PyQt designer, в котором создаем интерфейс.
Сохраняем файл, а затем с помощью библиотеки pyqt5-tool (pip install pyqt5-tools)
конвертируем дизайн в питоновский файл (pyuic5 ваш_файл.ui -o main.py)
Исходный файл ui не представлен в репозитории, но Вы можете посмотреть уже готовый сконвертированный файл,
который находится в main.py.

В интерфейсе мы вводим номер оператора и нажимаем подключиться.
После нажатия на кнопку мы переходим в метод connect класса Window, который наследует класс QMainWindow.
Проверяем подключение к серверу при помощи функции telnet_connect.
Если подключение успешно, тогда запускаем поток, который принимает ответ от сервера.
Поток нужен для того чтобы окно оставалось активным. Так как при запуске цикла while в функции listen_telnet,
метод stop становится недоступен. Это происходит из-за того,
что после вызова функции listen_telnet программа ожидает получить.
При входящем вызове получаем телефон звонящего и производим поск в базе абонентов.

Поиск производится в базе данных MySQL путем подключения с помощью библиотеки mysql-connector
и отправки запроса SQL например:
"SELECT * FROM 'имя таблицы, где хранятся абоненты' WHERE 'имя колонки где хранится телефон' LIKE 'номер телефона'",
а затем по полученному ответу формируется ссылка.

1) Если в ответе нет данных, то просто открыть биллинг.
2) Если ответ содержит один словарь с данными, то получаем идентификатор абонента.
   Это может быть id, login или любое другое уникальное поле
3) Если ответов несколько (>1) тогда выводим список всех абонентов с данным номером телефона.

При нажатии на кнопку отключиться мы устанавливаем флаг (shutdown_flag = 1).
Цикл закончит свою работу и выведет последний ответ от сервера.

Далее можно снова нажать кнопку подключить и все пойдет по новой.

В классе Window так же есть методы которые отвечаеют за интерфейс, описание каждого метода представленно
в виде комментариев, в теле класса.

КОМПИЛИРУЕМ В ИСПОЛНЯЕМЫЙ ФАЙЛ

Для того чтобы py конвертировать в exe нужно установить библиотеку pyinstaller.
Я установила его из репозитория.
pip install https://github.com/pyinstaller/pyinstaller/tarball/develop

Конвертируем
pyinstaller -F --noconsole main.py

-F - это флаг, который указывает на то что конвертировать нужно все в один файл;
--noconsole - в основном это нужно для Windows, чтобы консоль не открывалась;

P.s. Для того чтобы программа запускалась на разных операционных системах,
их нужно конвертировать на этих ОС.
Например в моем варинте мне нужен был exe для windows,
а у меня linux. Для этого я скачала проект на устройство с ОС windows.
Там создаем виртуальное окружение, устанавливаем пакеты из requirements и запукаем приложение.
Проверяем его работу и конвертируем.
(Исполняемы файл будет находиться в текущей директории, в папке dist)




